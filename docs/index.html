<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Making Sense of Uncertainty: Interactive Probability Demo</title>
<style>
  :root{--bg:#f7f8fb;--card:#fff;--ink:#111827;--muted:#6b7280;--border:#e5e7eb;--accent:#2563eb;}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--ink);background:var(--bg)}
  header{padding:20px 12px;text-align:center}
  h1{margin:0 0 6px;font-size:clamp(22px,3vw,30px)}
  .sub{margin:0;color:var(--muted)}
  .tabbar{display:flex;gap:8px;justify-content:center;padding:10px;flex-wrap:wrap}
  .tabbar button{border:1px solid var(--border);background:#fff;padding:8px 12px;border-radius:10px;
    cursor:pointer;font-weight:600}
  .tabbar button.active{background:var(--accent);border-color:var(--accent);color:#fff}
  main{max-width:1100px;margin:0 auto;padding:0 12px 36px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px}
  .grid{display:grid;gap:12px}
  @media(min-width:920px){.grid-2{grid-template-columns:1.05fr 1fr}.grid-2r{grid-template-columns:1fr 1.05fr}}
  h2{margin:.2rem 0 .5rem}
  h3{margin:.2rem 0 .4rem}
  .mini{font-size:.92rem}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .pill{display:inline-block;padding:3px 8px;border-radius:999px;background:#eef2ff;border:1px solid #e0e7ff;margin-right:6px}
  .svgwrap svg{max-width:100%;height:auto;display:block}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  label select,input[type="checkbox"]{padding:7px 8px;border:1px solid var(--border);border-radius:8px}
  .panel{background:#fafafa;border:1px dashed var(--border);padding:8px;border-radius:10px}
  .btn{background:#111827;color:#fff;border:none;border-radius:9px;padding:7px 10px;font-weight:600;cursor:pointer}
  .btn.secondary{background:#fff;color:#111827;border:1px solid var(--border)}
  .btn.success{background:#16a34a}
  .hr{height:1px;background:var(--border);margin:8px 0}
  /* spacing for event lists */
  #die-event-desc div,#dart-event-desc div{margin:6px 0;line-height:1.25}
  /* keep Experiment boxes containing their content neatly */
  .experiment{padding:10px}
  .experiment h3{margin:.2rem 0 .2rem}
  .experiment p{margin:.2rem 0 .65em}
</style>
</head>
<body>
<header>
  <h1>Making Sense of Uncertainty</h1>
  <p class="sub">Interactive models for sample spaces, events, conditional probability, independence, and Bayes theorem</p>
  <p class="sub" style="margin-top: 4px; font-size: 0.9em; opacity: 0.8;">Created by Fatemeh Hamidi-Sepehr</p>
</header>

<div class="tabbar">
  <button data-tab="notes">Lecture Notes</button>
  <button class="active" data-tab="die">4-Sided Die (Discrete Example)</button>
  <button data-tab="dart">Dart in Unit Square (Continuous Example)</button>
  <button data-tab="bayes">Bayes Rule Examples</button>
</div>

<main>

<!-- LECTURE NOTES TAB -->
  <section id="notes" class="tab card" style="display:none;">
      <iframe
        title="Lecture notes"
        style="width:100%; min-height: 1400px; border:0; border-radius: 12px;"
        srcdoc="&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
  &lt;title&gt;Introduction to Probability - Lecture Notes&lt;/title&gt;
  &lt;style&gt;
    :root { --fg:#1f1f1f; --muted:#4a4a4a; --accent:#003366; --border:#c8c8c8; --box:#fafafa; }
    html,body{margin:0;padding:0}
    body{font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; color:var(--fg); line-height:1.55; background:#fff;}
    .page{max-width:820px;margin:36px auto;padding:0 18px;}
    h1,h2,h3{color:var(--accent);margin:1.2em 0 .5em}
    h1{font-size:1.9rem;text-align:center}
    h2{font-size:1.35rem;border-bottom:1px solid var(--border);padding-bottom:.25rem}
    h3{font-size:1.1rem}
    p{margin:.65em 0;text-align:justify}
    .box{border-left:3px solid var(--border); padding:.6em .9em; background:var(--box); margin:.7em 0;}
    .theorem{border-left-color:#59b380}
    .proof{border-left-color:#b3598f}
    .remark{border-left-color:#888}
    .note{color:var(--muted); font-style:italic}
    .math{font-family:inherit}
    a{color:#0a58ca}
    .footer{margin-top:1.8rem;color:var(--muted);font-size:.95rem}
    @media print{
      a{color:#000;text-decoration:none}
      .page{margin:16px auto}
    }
  &lt;/style&gt;
  &lt;script&gt;
    // MathJax for TeX rendering
    window.MathJax = { tex: {inlineMath: [[&#x27;$&#x27;,&#x27;$&#x27;],[&#x27;\\(&#x27;,&#x27;\\)&#x27;]]} };
  &lt;/script&gt;
  &lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;page&quot;&gt;
  &lt;h1&gt;Making Sense of Uncertainty: Introduction to Probability&lt;/h1&gt;
  &lt;p class=&quot;note&quot;&gt;&lt;/p&gt;

  &lt;h2&gt;1. Introduction and Motivation&lt;/h2&gt;
  &lt;p&gt;
    Everyday life and nearly all professions (from finance and engineering to healthcare and retail) involve uncertainty, variability, and incomplete information.
    Probability provides the language and tools for reasoning under such uncertainty so that we can make educated decisions, design reliable systems, quantify risks,
    and update beliefs when information arrives. In this introductory module, we establish the foundations of probabilistic modeling and essential components (such as conditional probability, independence, etc.) that power later topics (such as statistical inference).
  &lt;/p&gt;

  &lt;h2&gt;2. Experiment, Sample Space, and Events&lt;/h2&gt;
  &lt;p&gt;
    An &lt;em&gt;experiment&lt;/em&gt; is an idealized procedure whose outcome cannot be predicted with certainty in advance
    (e.g., drawing a card, rolling dice, sampling a sensor). The set of all possible outcomes is the &lt;em&gt;sample space&lt;/em&gt; $\Omega$.
    An &lt;em&gt;event&lt;/em&gt; is a subset of $\Omega$; when the realized outcome lies in an event $A\subseteq\Omega$, we say that $A$ occurs.
  &lt;/p&gt;

  &lt;h2&gt;3. Properties of the Sample Space&lt;/h2&gt;

  &lt;p&gt;&lt;strong&gt;Definition.&lt;/strong&gt; As mentioned above, &lt;em&gt;sample space&lt;/em&gt; &lt;span class=&quot;math&quot;&gt;$\,\Omega\,$&lt;/span&gt; is the set of all
    elementary outcomes of an experiment. Each outcome is atomic at the modeling resolution we choose; events will
    later be formed as subsets (unions) of these atoms.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Requirements.&lt;/strong&gt; A well-posed &lt;span class=&quot;math&quot;&gt;$\,\Omega\,$&lt;/span&gt; must be
    &lt;em&gt;collectively exhaustive&lt;/em&gt; and &lt;em&gt;mutually exclusive&lt;/em&gt;. Collective exhaustiveness means that every
    physically or logically possible outcome of the experiment is represented in &lt;span class=&quot;math&quot;&gt;$\,\Omega\,$&lt;/span&gt;;
    whatever happens, the realized outcome lies in &lt;span class=&quot;math&quot;&gt;$\,\Omega\,$&lt;/span&gt;. Mutual exclusivity means that
    two distinct elements of &lt;span class=&quot;math&quot;&gt;$\,\Omega\,$&lt;/span&gt; cannot occur simultaneously; in any single
    performance of the experiment, &lt;strong&gt;exactly one&lt;/strong&gt; element of &lt;span class=&quot;math&quot;&gt;$\,\Omega\,$&lt;/span&gt; occurs.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Modeling granularity.&lt;/strong&gt; The level of detail in
    &lt;span class=&quot;math&quot;&gt;$\,\Omega\,$&lt;/span&gt; is a modeling choice and should be driven by the question of interest.
    Real situations contain many details; a good model excludes irrelevant detail while ensuring that every listed
    outcome is actually possible. There is necessarily an element of judgment (“art”) in selecting the right
    granularity.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Examples.&lt;/strong&gt; For a single coin toss, a minimal description is
    &lt;span class=&quot;math&quot;&gt;$\,\Omega=\{H,T\}\,$&lt;/span&gt;, which meets the above requirements. If the
    phenomenon of interest also depends on weather, one may refine the space to encode that context:
    &lt;span class=&quot;math&quot;&gt;$\,\Omega=\{(H,\mathrm{rain}),(H,\mathrm{not\mbox{-}rain}),(T,\mathrm{rain}),(T,\mathrm{not\mbox{-}rain})\}\,$&lt;/span&gt; or  &lt;span class=&quot;math&quot;&gt;$\,\Omega=\{H,(T,\mathrm{rain}),(T,\mathrm{not\mbox{-}rain})\}\,$&lt;/span&gt;.
    While these choices are legitimate, the refined space should only be
    used when the added dimension is relevant.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Practical guideline.&lt;/strong&gt; Before defining events and probabilities, verify:
    (i) no possible outcome has been omitted (collective exhaustiveness);
    (ii) outcomes do not overlap (mutual exclusivity);
    (iii) the chosen granularity matches the questions you will ask of the model.&lt;/p&gt;

  &lt;h2&gt;4. Probability Law, and Probability Axioms&lt;/h2&gt;
  &lt;p&gt;
    A &lt;em&gt;probability law&lt;/em&gt; (or probability measure) on $\Omega$ assigns to every event $A\subseteq\Omega$ a real number $\mathbb{P}(A)$
    interpreted as the chance that $A$ occurs. In other words, the probability law describes our beliefs about which outcomes are more likely to occur compared to other outcomes. Probability laws have to obey
certain properties that we call the axioms of probability:
  &lt;/p&gt;
  &lt;p class=&quot;box&quot;&gt;
    &lt;strong&gt;Axioms.&lt;/strong&gt; For all events $A,B\subseteq\Omega$:&lt;br&gt;
    (i) Nonnegativity: $0\le \mathbb{P}(A)$.&lt;br&gt;
    (ii) Total probability (Normalization): $\mathbb{P}(\Omega)=1$.&lt;br&gt;
    (iii) Additivity of disjoint events: If $A\cap B=\varnothing$ (disjoint), then $\mathbb{P}(A\cup B)=\mathbb{P}(A)+\mathbb{P}(B)$.
  &lt;/p&gt;

  &lt;h2&gt;5. Results and Consequences of the Axioms&lt;/h2&gt;
  &lt;div class=&quot;box theorem&quot;&gt;&lt;strong&gt;Result 4.1 (Empty Set).&lt;/strong&gt; $\mathbb{P}(\varnothing)=0$.&lt;/div&gt;
  &lt;div class=&quot;box proof&quot;&gt;&lt;strong&gt;Proof.&lt;/strong&gt; Since $\Omega = \Omega \cup \varnothing$ and $\Omega \cap \varnothing=\varnothing$, axiom (iii) gives
  $\mathbb{P}(\Omega) = \mathbb{P}(\Omega)+\mathbb{P}(\varnothing)$; subtract to get $\mathbb{P}(\varnothing)=0$. $\square$&lt;/div&gt;

  &lt;div class=&quot;box theorem&quot;&gt;&lt;strong&gt;Result 4.2 (Complement).&lt;/strong&gt; For $A\subseteq\Omega$, $\mathbb{P}(A^c)=1-\mathbb{P}(A)$.&lt;/div&gt;
  &lt;div class=&quot;box proof&quot;&gt;&lt;strong&gt;Proof.&lt;/strong&gt; $\Omega = A\cup A^c$ and $A\cap A^c=\varnothing$. By (ii) and (iii),
  $1=\mathbb{P}(\Omega)=\mathbb{P}(A)+\mathbb{P}(A^c)$, hence $\mathbb{P}(A^c)=1-\mathbb{P}(A)$. $\square$&lt;/div&gt;


  &lt;div class=&quot;box theorem&quot;&gt;&lt;strong&gt;Result 4.3 (Less than unity).&lt;/strong&gt; $\mathbb{P}(A) \le 1$.&lt;/div&gt;
  &lt;div class=&quot;box proof&quot;&gt;&lt;strong&gt;Proof.&lt;/strong&gt; Direct consequence of Result 4.2. $\square$&lt;/div&gt;

  &lt;div class=&quot;box theorem&quot;&gt;&lt;strong&gt;Result 4.4 (Monotonicity).&lt;/strong&gt; If $A\subseteq B$, then $\mathbb{P}(A)\le \mathbb{P}(B)$.&lt;/div&gt;
  &lt;div class=&quot;box proof&quot;&gt;&lt;strong&gt;Proof.&lt;/strong&gt; Write $B = A\cup (B\setminus A)$ with disjoint union; by (iii),
  $\mathbb{P}(B)=\mathbb{P}(A)+\mathbb{P}(B\setminus A)\ge \mathbb{P}(A)$. $\square$&lt;/div&gt;

  &lt;div class=&quot;box theorem&quot;&gt;&lt;strong&gt;Result 4.5 (Finite Additivity).&lt;/strong&gt; If $A_1,\dots,A_n$ are pairwise disjoint, then
  $\mathbb{P}\Big(\bigcup_{i=1}^n A_i\Big)=\sum_{i=1}^n \mathbb{P}(A_i)$.&lt;/div&gt;
  &lt;div class=&quot;box proof&quot;&gt;&lt;strong&gt;Proof.&lt;/strong&gt; Induct on $n$. The case $n=2$ is axiom (iii); extend by induction. $\square$&lt;/div&gt;

  &lt;div class=&quot;box theorem&quot;&gt;&lt;strong&gt;Result 4.6 (Inclusion-Exclusion).&lt;/strong&gt; $\mathbb{P}(A\cup B)=\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(A\cap B)$.&lt;/div&gt;
  &lt;div class=&quot;box proof&quot;&gt;&lt;strong&gt;Proof.&lt;/strong&gt;
  Write the disjoint pieces
  $A\setminus B:=A\cap B^{c}$ and $B\setminus A:=B\cap A^{c}$.
  Then
  $$A\cup B=(A\setminus B)\ \cup\ (B\setminus A)\ \cup\ (A\cap B)$$
  is a disjoint union. By finite additivity,
  $$\mathbb{P}(A\cup B)=\mathbb{P}(A\setminus B)+\mathbb{P}(B\setminus A)+\mathbb{P}(A\cap B).$$
  Also
  $$\mathbb{P}(A)=\mathbb{P}(A\setminus B)+\mathbb{P}(A\cap B),\qquad
    \mathbb{P}(B)=\mathbb{P}(B\setminus A)+\mathbb{P}(A\cap B).$$
  Adding these two equalities gives
  $$\mathbb{P}(A)+\mathbb{P}(B)=\mathbb{P}(A\setminus B)+\mathbb{P}(B\setminus A)+2\,\mathbb{P}(A\cap B).$$
  Subtract $\mathbb{P}(A\cap B)$ from both sides and use the first display to obtain
  $$\mathbb{P}(A\cup B)=\mathbb{P}(A)+\mathbb{P}(B)-\mathbb{P}(A\cap B).$$
  $\square$
&lt;/div&gt;

  &lt;h2&gt;6. Partitioning Consequence&lt;/h2&gt;
  &lt;div class=&quot;box theorem&quot;&gt;&lt;strong&gt;Proposition 5.1 (Partition Identity).&lt;/strong&gt; If $\{B_i\}_{i=1}^n$ is a partition of $\Omega$
  (pairwise disjoint and $\bigcup_i B_i=\Omega$), then for any event $A$,
  $$\mathbb{P}(A)=\sum_{i=1}^n \mathbb{P}(A\cap B_i)\,.$$
  &lt;/div&gt;
  &lt;div class=&quot;box proof&quot;&gt;&lt;strong&gt;Proof.&lt;/strong&gt; Since $A=A\cap\Omega=A\cap\big(\cup_i B_i\big)=\cup_i (A\cap B_i)$ with disjoint union, apply Result 4.5. $\square$&lt;/div&gt;

  &lt;h2&gt;7. Discrete Uniform Law&lt;/h2&gt;
  &lt;p&gt;
    In the finite &lt;em&gt;equi-likely&lt;/em&gt; model, each outcome $\omega\in\Omega$ has the same probability. If $|\Omega|=n$,
    then for any event $A\subseteq\Omega$,
    $$\mathbb{P}(A)=\frac{|A|}{|\Omega|}=\frac{|A|}{n}.$$
  &lt;/p&gt;
  &lt;div class=&quot;box proof&quot;&gt;&lt;strong&gt;Proof.&lt;/strong&gt; Let $\mathbb{P}(\{\omega\})=p$ for all outcomes. Then
  $1=\mathbb{P}(\Omega)=\sum_{\omega\in\Omega} p = np$, hence $p=1/n$, and $\mathbb{P}(A)=\sum_{\omega\in A} p = |A|/n$. $\square$
This is one example of a probability law, which assumes (i) finitely many outcomes and (ii) all equally likely. Such assumption is usually reasonable for symmetric finite settings, e.g. fair dice, each side with probability 1/6.
Problems of the discrete uniform law reduce to counting: How many elements are there in my sample space? How many elements are there inside the event of interest?

&lt;/div&gt;

  &lt;h2&gt;8. Counting Possible Outcomes of Combined Experiments&lt;/h2&gt;
  &lt;p&gt;
    Many experiments can be modeled as a finite sequence of sub-experiments (or steps). Suppose step
    &lt;span class=&quot;math&quot;&gt;$j$&lt;/span&gt; offers exactly &lt;span class=&quot;math&quot;&gt;$n_j$&lt;/span&gt; admissible outcomes at the
    modeling resolution of interest. When the number of options at each step does &lt;em&gt;not&lt;/em&gt; depend on the
    specific outcomes chosen at earlier steps, the total number of composite outcomes is obtained by multiplying
    the per-step counts.
  &lt;/p&gt;

  &lt;div class=&quot;box theorem&quot;&gt;&lt;strong&gt;Multiplication Principle.&lt;/strong&gt;
    If an experiment consists of &lt;span class=&quot;math&quot;&gt;$r$&lt;/span&gt; steps and step
    &lt;span class=&quot;math&quot;&gt;$j$&lt;/span&gt; has &lt;span class=&quot;math&quot;&gt;$n_j$&lt;/span&gt; possible outcomes
    (independent of the outcomes chosen at steps &lt;span class=&quot;math&quot;&gt;$1,\dots,j-1$&lt;/span&gt;),
    then the total number of outcomes is
    &lt;span class=&quot;math&quot;&gt;$$N=\prod_{j=1}^{r} n_j \;=\; n_1 n_2 \cdots n_r.$$&lt;/span&gt;
  &lt;/div&gt;

  &lt;div class=&quot;box proof&quot;&gt;&lt;strong&gt;Proof.&lt;/strong&gt;
    By induction on &lt;span class=&quot;math&quot;&gt;$r$&lt;/span&gt;. For &lt;span class=&quot;math&quot;&gt;$r=1$&lt;/span&gt; the claim is obvious.
    Assume the result for &lt;span class=&quot;math&quot;&gt;$r-1$&lt;/span&gt; steps: any sequence of the first
    &lt;span class=&quot;math&quot;&gt;$r-1$&lt;/span&gt; steps has &lt;span class=&quot;math&quot;&gt;$n_1\cdots n_{r-1}$&lt;/span&gt; possibilities.
    By the independence-of-counts assumption, each such partial outcome can be extended in exactly
    &lt;span class=&quot;math&quot;&gt;$n_r$&lt;/span&gt; ways at step &lt;span class=&quot;math&quot;&gt;$r$&lt;/span&gt;. Therefore the total is
    &lt;span class=&quot;math&quot;&gt;$(n_1\cdots n_{r-1})\,n_r = \prod_{j=1}^{r} n_j$&lt;/span&gt;.  &amp;#9633;
  &lt;/div&gt;

  &lt;p&gt;
    A common special case is a two-step process with &lt;span class=&quot;math&quot;&gt;$A$&lt;/span&gt; options at the first step and
    &lt;span class=&quot;math&quot;&gt;$B$&lt;/span&gt; options at the second (independent of the first); then the total number of outcomes is
    &lt;span class=&quot;math&quot;&gt;$A\times B$&lt;/span&gt;.
  &lt;/p&gt;

  &lt;div class=&quot;box theorem&quot;&gt;&lt;strong&gt;Sum Rule (Disjoint Case Analysis).&lt;/strong&gt;
    If all outcomes arise from exactly one of several disjoint cases, with counts
    &lt;span class=&quot;math&quot;&gt;$N_1,N_2,\dots,N_k$&lt;/span&gt;, then the total number of outcomes is
    &lt;span class=&quot;math&quot;&gt;$$N=\sum_{i=1}^{k} N_i.$$&lt;/span&gt;
  &lt;/div&gt;

  &lt;div class=&quot;box proof&quot;&gt;&lt;strong&gt;Proof.&lt;/strong&gt;
    The outcome set is the disjoint union of the case sets; cardinality is additive over disjoint unions. &amp;#9633;
  &lt;/div&gt;

  &lt;h3&gt;When (and how) to adjust the product&lt;/h3&gt;

  &lt;p&gt;&lt;strong&gt;Dependence of counts (non-uniform options).&lt;/strong&gt;
    If earlier choices change the number of options later &lt;em&gt;in a non-uniform way&lt;/em&gt;, one cannot use a single
    product. Perform &lt;em&gt;casework&lt;/em&gt;: split by the early choice, multiply within each case, then add the case totals
    (Sum Rule).&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;With vs. without replacement.&lt;/strong&gt;
    Replacement affects the factors you multiply, not the principle. With replacement, the factors remain constant
    at each step; without replacement, they decrease (e.g., &lt;span class=&quot;math&quot;&gt;$n,\ n-1,\ n-2,\dots$&lt;/span&gt;), and you still
    multiply those stepwise counts.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Order (labels/roles) matters vs. not.&lt;/strong&gt;
    If outcomes are &lt;em&gt;ordered&lt;/em&gt; (labeled slots or roles), the multiplication principle applies directly (“first slot,
    second slot, …”). If outcomes are &lt;em&gt;unordered&lt;/em&gt;, first count as though labeled (multiply), then divide out the
    symmetry to correct over-counting (e.g., unordered pairs from &lt;span class=&quot;math&quot;&gt;$n$&lt;/span&gt; items are
    &lt;span class=&quot;math&quot;&gt;$\frac{n(n-1)}{2}$&lt;/span&gt; because ordered pairs give &lt;span class=&quot;math&quot;&gt;$n(n-1)$&lt;/span&gt; and each pair is
    counted twice).&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Sequential vs. simultaneous descriptions.&lt;/strong&gt;
    Whether you conceptually choose options one after another (sequential) or all at once (simultaneous) is mostly cosmetic;
    what matters is (i) are you treating outcomes as ordered or unordered, and (ii) do later option counts change uniformly.
    The rule of product remains the backbone; you may need a “divide out symmetry” or “sum over cases” step on top.&lt;/p&gt;

  &lt;div class=&quot;box remark&quot;&gt;&lt;strong&gt;Takeaway.&lt;/strong&gt;
    Whenever an experiment admits a decomposition into steps with well-defined counts
    &lt;span class=&quot;math&quot;&gt;$n_1,n_2,\dots,n_r$&lt;/span&gt; that do not depend on earlier outcomes, the total number of outcomes is
    &lt;span class=&quot;math&quot;&gt;$n_1 n_2 \cdots n_r$&lt;/span&gt;. If that independence of counts fails, use case analysis:
    multiply within each case and add across cases.
  &lt;/div&gt;

  &lt;h2&gt;9. Examples (Setting and Interactive Model)&lt;/h2&gt;
  &lt;p&gt;
    For exploration, use the other tabs on the right, where you can interactively play with and learn from insightful examples.
  &lt;/p&gt;

  &lt;h2&gt;10. Conditional Events and Probabilities&lt;/h2&gt;
  &lt;p&gt;
    How does the probability of an event change if we have extra information on some other events? Given an event $B$ with $\mathbb{P}(B)&gt;0$, the &lt;em&gt;conditional probability&lt;/em&gt; of $A$ given $B$ is
    $$\mathbb{P}(A\mid B)=\frac{\mathbb{P}(A\cap B)}{\mathbb{P}(B)}.$$
    This represents the probability of $A$ after restricting attention to outcomes in $B$ (somewhat reducing the sample space).
    Equivalently, one can write $\mathbb{P}(A\cap B)=\mathbb{P}(B)\,\mathbb{P}(A\mid B)$, which is known as the &lt;strong&gt;Multiplication Rule&lt;/strong&gt; and has various applications in probability, statistics theory, and inference.
  &lt;/p&gt;

  &lt;h2&gt;11. Independence vs. Disjointness&lt;/h2&gt;
  &lt;p&gt;
    Events $A$ and $B$ are &lt;em&gt;independent&lt;/em&gt; if
    $$\mathbb{P}(A\cap B)=\mathbb{P}(A)\,\mathbb{P}(B).$$
    Independence means that knowing $B$ does not change the probability of $A$ (and vice versa): $\mathbb{P}(A\mid B)=\mathbb{P}(A)$.
    In contrast, &lt;em&gt;disjoint&lt;/em&gt; events (with $A\cap B=\varnothing$) cannot occur together; disjointness does &lt;em&gt;not&lt;/em&gt; imply independence
    unless one of the events has probability zero.
  &lt;/p&gt;

  &lt;h2&gt;12. Inversion of Conditional Probability (Finding $\mathbb{P}(B\mid A)$ from $\mathbb{P}(A\mid B)$) and Bayes’ Rule Foundations&lt;/h2&gt;
  &lt;p&gt;
    By definition, and using the multiplication rule, $\mathbb{P}(A\cap B)=\mathbb{P}(A)\,\mathbb{P}(B\mid A)=\mathbb{P}(B)\,\mathbb{P}(A\mid B)$ (when the denominators are positive).
    Rearranging gives the inversion formula (Bayes’ theorem):
    $$\mathbb{P}(B\mid A)=\frac{\mathbb{P}(A\mid B)\,\mathbb{P}(B)}{\mathbb{P}(A)}.$$
The idea is to use what we can measure, i.e., $\mathbb{P}(A\mid B)$ and $\mathbb{P}( B)$, to infer what we want, i.e., $\mathbb{P}(B\mid A)$.
Bayes Theorem is a fundamental concept in probability theory, which allows us to update our beliefs about an event based on new information.
It is widely used in statistics, machine learning, and engineering inference.


  &lt;/p&gt;

  &lt;h2&gt;13. Law of Total Probability and Its Role in Bayes&lt;/h2&gt;
  &lt;p&gt;
    &lt;div class=&quot;box theorem&quot;&gt;&lt;strong&gt;Law of Total Probability (finite partition).&lt;/strong&gt;
  If $\{B_i\}_{i=1}^n$ forms a partition of $\Omega$ with $\mathbb{P}(B_i)&gt;0$ for all $i$, then for any event $A$,
  $$\mathbb{P}(A)=\sum_{i=1}^n \mathbb{P}(A\mid B_i)\,\mathbb{P}(B_i).$$
&lt;/div&gt;

&lt;div class=&quot;box proof&quot;&gt;&lt;strong&gt;Proof.&lt;/strong&gt;
  Because $\{B_i\}$ is a partition of $\Omega$, we have the disjoint union
  $$A \;=\; A\cap\Omega \;=\; A\cap\!\Big(\bigcup_{i=1}^n B_i\Big)
     \;=\; \bigcup_{i=1}^n \big(A\cap B_i\big).$$
  By finite additivity over disjoint sets,
  $$\mathbb{P}(A)=\sum_{i=1}^n \mathbb{P}(A\cap B_i).$$
  For each $i$ with $\mathbb{P}(B_i)&gt;0$, the definition of conditional probability gives
  $$\mathbb{P}(A\cap B_i)=\mathbb{P}(A\mid B_i)\,\mathbb{P}(B_i).$$
  Substituting into the previous sum yields
  $$\mathbb{P}(A)=\sum_{i=1}^n \mathbb{P}(A\mid B_i)\,\mathbb{P}(B_i),$$
  as claimed. $\square$
&lt;/div&gt;
    In Bayesian inference, this expresses the &lt;em&gt;marginal likelihood&lt;/em&gt; (or evidence) as a weighted sum over cases $B_i$;
    Bayes’ rule then updates beliefs by combining this denominator with the likelihood $\mathbb{P}(A\mid B_i)$ and prior $\mathbb{P}(B_i)$.
  &lt;/p&gt;

  &lt;h2&gt;14. Morals and Course Trajectory&lt;/h2&gt;
  &lt;p&gt;
    &lt;strong&gt;Morals.&lt;/strong&gt; Distinguish disjointness from independence; use conditioning carefully; and remember the partition identity as the engine behind
    the law of total probability and Bayes’ updates.
  &lt;/p&gt;
  &lt;p&gt;
    &lt;strong&gt;Trajectory.&lt;/strong&gt; From here, we deepen counting methods, introduce random variables (discrete and continuous), develop distributions, expectation,
    and ultimately study limit theorems and classical statistical procedures.
  &lt;/p&gt;

&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
">
      </iframe>
  </section>

<!-- DIE TAB -->
  <section id="die" class="tab card">
    <div class="grid grid-2">
      <div>
        <div class="card experiment">
          <h3>Experiment</h3>
          <p class="mini" style="color:#475569">Roll a 4-sided die twice. Sample space Ω has 16 equally likely outcomes: (x,y) with x,y ∈ {1,2,3,4}.</p>
          <div class="panel">
            <div class="row">
              <label>Event A: <select id="die-event-a"></select></label>
              <label style="margin-top: 8px;">Event B: <select id="die-event-b"></select></label>
              <label class="row" style="gap:6px;"><input type="checkbox" id="die-show-only"> Show only selected leaves</label>
            </div>
          </div>
          <div style="margin-top: 10px;"></div>
          <div class="grid">
            <div class="card">
              <h3>Tree Representation (two stages)</h3>
              <div style="margin-top: 20px;"></div>
              <div class="mini" style="text-align:right; margin-top:-6px; margin-bottom:6px;">
                <span class="pill" style="background: #93c5fd; border-color: #60a5fa;">Event A</span>
                <span class="pill" style="background: #fda4af; border-color: #f87171;">Event B</span>
                <span class="pill" style="background: #86efac; border-color: #4ade80;">Event A∩B</span>
              </div>
              <div class="svgwrap"><svg id="die-tree" width="520" height="360"></svg></div>
            </div>
            <div class="card">
              <h3>Sample Space (Ω)</h3>
              <div id="die-space" class="mono" style="display:grid;grid-template-columns:repeat(4,minmax(44px,1fr));gap:6px"></div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px">
          <h3>Predefined Events (discrete)</h3>
          <div id="die-event-desc" class="mini"></div>
        </div>
      </div>

      <div>
        <div class="card">
          <h3>Sample Space Grid</h3>
          <div style="margin-top: 20px;"></div>
          <div class="svgwrap"><svg id="die-grid" width="460" height="320" style="border:1px solid #e5e7eb; background:#ffffff"></svg></div>
        </div>
        <div style="margin-top: 10px;"></div>
        <div class="card">
          <h3>Adaptive Venn Diagram</h3>
          <div style="margin-top: 20px;"></div>
          <div class="mini" style="text-align:right; margin-top:-6px; margin-bottom:6px;">
            <span class="pill" style="background: #93c5fd; border-color: #60a5fa;">Event A</span>
            <span class="pill" style="background: #fda4af; border-color: #f87171;">Event B</span>
          </div>
          <div class="svgwrap"><svg id="die-venn" width="460" height="320"></svg></div>
        </div>
        <div style="margin-top: 10px;"></div>
        <div class="card">
          <h3>Probabilities (Discrete Uniform Law)</h3>
          <div id="die-stats" class="mono mini"></div>
          <div class="hr"></div>
          <div id="die-rel" class="mini"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- DART TAB -->
  <section id="dart" class="tab card" style="display:none;">
    <div class="grid grid-2r">
      <div>
        <h2>Experiment</h2>
        <div class="card experiment">
          <p class="mini" style="color:#475569; text-align: justify; margin:0 0 0 0;">
            Throw darts uniformly in the unit square [0,1]².
          </p>
          <ul class="mini" style="color:#475569; text-align: justify; margin:0; padding-left:1.2rem;">
            <li>The sample space is set of x–y pairs that lie between 0 and 1 (continuous & infinite). Outcome is a point (x,y) ∈ [0,1]².</li>
            <li>Events are measurable regions.</li>
            <li>Probabilities correspond to areas.</li>
            <li>Probability law: assume “equal areas = equal probabilities” convention.</li>
          </ul>
          <div class="panel">
            <div class="row">
              <label>Event A: <select id="dart-event-a"></select></label>
              <label style="margin-top: 8px;">Event B: <select id="dart-event-b"></select></label>
            </div>
            <div style="margin-top: 10px;"></div>
            <div class="mini"><span class="pill" style="background: #93c5fd; border-color: #60a5fa;">Event A</span><span class="pill" style="background: #fda4af; border-color: #f87171;">Event B</span></div>
          </div>

          <div class="card" style="margin-top:10px">
            <h3>Unit Square Visualization</h3>
            <!-- scaled-down to avoid clipping -->
            <div class="svgwrap"><svg id="dart-svg" width="460" height="460"></svg></div>
            <div class="mini" style="margin:6px 0 12px; display:flex; gap:8px; align-items:center;">
              <span class="pill">Sample Space</span>
              <svg id="dart-mini" width="160" height="160"></svg>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px">
          <h3>Predefined Events (continuous)</h3>
          <div id="dart-event-desc" class="mini"></div>
        </div>
      </div>

      <div>
        <h2>Calculations & Venn</h2>
        <div class="card">
          <h3>Theoretical Areas</h3>
          <div id="dart-theory" class="mono mini"></div>
          <div id="dart-rel-top" class="mini" style="margin-top:6px;"></div>
        </div>
        <div style="margin-top: 10px;"></div>
        <div class="card">
          <h3>Adaptive Venn Diagram</h3>
          <div class="svgwrap"><svg id="dart-venn" width="460" height="320"></svg></div>
        </div>
        <div style="margin-top: 10px;"></div>
        <div class="card">
          <h3>Empirical Probabilities</h3>
          <div class="row" style="gap:8px;margin-bottom:6px">
            <button class="btn success" id="dart-throw-500">Throw 500</button>
            <button class="btn success" id="dart-throw-2000">Throw 2000</button>
            <button class="btn secondary" id="dart-reset">Reset</button>
          </div>
          <div id="dart-stats" class="mono mini"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- BAYES TAB -->
  <section id="bayes" class="tab card" style="display:none;">
    <div class="grid grid-2">
      <div>
        <div class="card">
          <div style="margin-bottom: 12px;">
            <label class="mini">P(A) (prior): <span id="ba-prior-val" class="pill">0.30</span></label>
            <input id="ba-prior" type="range" min="0.01" max="0.99" step="0.01" value="0.30">
          </div>
          <div style="margin-bottom: 12px;">
            <label class="mini">P(B|A) (updated likelihood): <span id="ba-likea-val" class="pill">0.80</span></label>
            <input id="ba-likea" type="range" min="0.01" max="0.99" step="0.01" value="0.80">
          </div>
          <div>
            <label class="mini">P(B|A<sup>c</sup>): <span id="ba-likenot-val" class="pill">0.20</span></label>
            <input id="ba-likenot" type="range" min="0.01" max="0.99" step="0.01" value="0.20">
          </div>
        </div>

        <div class="card" style="margin-top: 12px;">
          <h2>Calculation</h2>
          <div class="card mono" style="margin-bottom: 8px; padding: 8px; border: 1px solid var(--border);">
            <div>P(A|B) = P(B|A)·P(A) / P(B)</div>
          </div>
          <div class="card mono" style="margin-bottom: 8px; padding: 8px; border: 1px solid var(--border);">
            <div>P(B) = P(B|A)·P(A) + P(B|A<sup>c</sup>)·(1−P(A))</div>
          </div>
          <div class="card mono" style="margin-bottom: 8px; padding: 8px; border: 1px solid var(--border);">
            <div id="ba-evidence-line"></div>
          </div>
          <div class="card mono" style="margin-bottom: 8px; padding: 8px; border: 1px solid var(--border);">
            <div id="ba-posterior" style="font-weight:700;color:#2563eb"></div>
          </div>
        </div>
      </div>

      <div>
        <div class="card">
          <h3>Visualizations</h3>
          <svg id="bayes-bars" width="520" height="220"></svg>
        </div>
      </div>
    </div>


    <div class="card" style="margin-top:10px">
      <h3>Notes</h3>
      <div class="mini">
        <ul style="margin:0 0 0 1rem; padding:0;"><li>P(A): Prior.</li><li>P(B): Evidence; usually calculated using the law of total probability.</li><li>P(A|B): Posterior (updated belief in A after observing evidence B).</li><li>Posterior increases with larger P(B|A) and larger prior P(A).</li><li>High false-positive rate P(B|A<sup>c</sup>) inflates evidence and can reduce P(A|B).</li><li>Small base rates (rare conditions) can keep P(A|B) modest even with accurate tests.</li></ul>
      </div>
    </div>

    <div class="card" style="margin-top:10px">
      <h3>Example: Medical Testing</h3>
      <p class="mini">Suppose a disease has prevalence P(A)=1%. The test has sensitivity P(B|A)=0.95 and false-positive rate P(B|A<sup>c</sup>)=0.05.</p>
      <button class="btn secondary" id="ba-medical">Load Solution</button>
      <div class="mono mini" id="ba-medical-out" style="margin-top:8px"></div>
    </div>

    <div class="card" style="margin-top:10px">
      <h3>Example: Spam Detection</h3>
      <p class="mini">Let A = "message is spam", B = "message contains strong spam keywords (e.g., <em>FREE</em>, <em>WIN</em>)". Assume P(A)=0.20, P(B|A)=0.90, P(B|A<sup>c</sup>)=0.10.</p>
      <button class="btn secondary" id="ba-spam">Load Solution</button>
      <div class="mono mini" id="ba-spam-out" style="margin-top:8px"></div>
    </div>

    <div class="card" style="margin-top:10px">
      <h3>Example: Click Prediction with Three Segments</h3>
      <p class="mini">
        Partition users into three disjoint segments (a partition of &Omega;): H<sub>1</sub> = new (50%), H<sub>2</sub> = occasional (30%), H<sub>3</sub> = loyal (20%).<br>
        Let B = "clicks the banner". Suppose P(B|H<sub>1</sub>)=0.05, P(B|H<sub>2</sub>)=0.12, P(B|H<sub>3</sub>)=0.30.
      </p>
      <button class="btn secondary" id="ba-click">Load Solution</button>
      <div class="mono mini" id="ba-click-out" style="margin-top:8px"></div>
    </div>
  </section>
</main>

<script>
/* TABS */
const tabs = document.querySelectorAll('.tabbar button');
const sections = document.querySelectorAll('section.tab');
tabs.forEach(btn=>btn.addEventListener('click',()=>{
  tabs.forEach(b=>b.classList.remove('active')); btn.classList.add('active');
  const key = btn.dataset.tab;
  sections.forEach(s=> s.style.display = (s.id===key?'block':'none'));
}));

/* UTIL */
const byId = id => document.getElementById(id);
const setText = (id, html) => byId(id).innerHTML = html;
const fmtProb = p => (Math.round(p*1000)/1000).toFixed(3);

/* Venn helpers */
function circleIntersectionArea(r0, r1, d){
  if(d >= r0 + r1) return 0;
  if(d <= Math.abs(r0 - r1)) return Math.PI * Math.min(r0, r1) ** 2;
  const r0sq = r0*r0, r1sq = r1*r1;
  const alpha = Math.acos((d*d + r0sq - r1sq)/(2*d*r0));
  const beta  = Math.acos((d*d + r1sq - r0sq)/(2*d*r1));
  return r0sq*alpha + r1sq*beta - 0.5*Math.sin(2*alpha)*r0sq - 0.5*Math.sin(2*beta)*r1sq;
}
function distanceForTargetOverlap(r0, r1, targetArea){
  const maxOverlap = Math.PI * Math.min(r0, r1) ** 2;
  if(targetArea <= 1e-9) return r0 + r1 + 12;
  if(targetArea >= maxOverlap - 1e-9) return 0;
  let lo = Math.abs(r0 - r1), hi = r0 + r1, mid = 0;
  for(let it=0; it<40; it++){
    mid = (lo + hi) / 2;
    const area = circleIntersectionArea(r0, r1, mid);
    if(area > targetArea) lo = mid; else hi = mid;
  }
  return (lo+hi)/2;
}
function addRect(svg,x,y,w,h,fill,stroke){ const r = document.createElementNS('http://www.w3.org/2000/svg','rect'); r.setAttribute('x',x); r.setAttribute('y',y); r.setAttribute('width',w); r.setAttribute('height',h); r.setAttribute('rx',12); r.setAttribute('fill',fill); r.setAttribute('stroke',stroke); svg.appendChild(r); }
function addCircleSVG(svg,x,y,r,fill,stroke){ const c=document.createElementNS('http://www.w3.org/2000/svg','circle'); c.setAttribute('cx',x); c.setAttribute('cy',y); c.setAttribute('r',r); c.setAttribute('fill',fill); c.setAttribute('stroke',stroke); c.setAttribute('stroke-width','1.5'); svg.appendChild(c); }
function addText(svg,x,y,text,size='12px',fill='#111'){ const t=document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x',x); t.setAttribute('y',y); t.setAttribute('font-size',size); t.setAttribute('fill',fill); t.textContent=text; svg.appendChild(t); }

/* DIE */
const outcomes = []; for(let x=1;x<=4;x++){ for(let y=1;y<=4;y++){ outcomes.push(`(${x},${y})`);} }
const Ω = outcomes.slice();

const dieEvents = {
  E1: { name: "Event 1: {(x,y) = (1,1) or (1,2)}", outcomes: ["(1,1)","(1,2)"] },
  E2: { name: "Event 2: {x = 1}", outcomes: ["(1,1)","(1,2)","(1,3)","(1,4)"] },
  E3: { name: "Event 3: {x + y is odd}", outcomes: ["(1,2)","(1,4)","(2,1)","(2,3)","(3,2)","(3,4)","(4,1)","(4,3)"] },
  E4: { name: "Event 4: {min(x,y)=2}", outcomes: ["(2,2)","(2,3)","(2,4)","(3,2)","(4,2)"] },
  E5: { name: "Event 5: {y = 4}", outcomes: ["(1,4)","(2,4)","(3,4)","(4,4)"] },
  E6: { name: "Event 6: {x = y (diagonal)}", outcomes: ["(1,1)","(2,2)","(3,3)","(4,4)"] },
  E7: { name: "Event 7: {max(x,y)=4}", outcomes: ["(4,1)","(4,2)","(4,3)","(4,4)","(1,4)","(2,4)","(3,4)"] },
  E8: { name: "Event 8: {x + y ≤ 3}", outcomes: ["(1,1)","(1,2)","(2,1)"] },
  E9: { name: "Event 9: {x + y ≥ 6}", outcomes: ["(2,4)","(3,3)","(3,4)","(4,2)","(4,3)","(4,4)"] },
  E10:{ name: "Event 10: {y is even (2 or 4)}", outcomes: ["(1,2)","(2,2)","(3,2)","(4,2)","(1,4)","(2,4)","(3,4)","(4,4)"] }
};
function probOf(set){ return set.length / Ω.length; }
function inter(a,b){ return a.filter(x=>b.includes(x)); }
function union(a,b){ return Array.from(new Set(a.concat(b))); }
function subset(a,b){ return a.every(x=>b.includes(x)); }

function populateDieSelectors(){
  const selA = byId('die-event-a'), selB = byId('die-event-b');
  // Insert a '(none)' option at the top
  const noneA = document.createElement('option'); noneA.value = ""; noneA.textContent = "— (none) —"; selA.appendChild(noneA);
  const noneB = document.createElement('option'); noneB.value = ""; noneB.textContent = "— (none) —"; selB.appendChild(noneB);
  // Existing predefined events
  Object.entries(dieEvents).forEach(([k,v])=>{
    let o1 = document.createElement('option'); o1.value=k; o1.textContent=v.name; selA.appendChild(o1);
    let o2 = document.createElement('option'); o2.value=k; o2.textContent=v.name; selB.appendChild(o2);
  });
  // Defaults: A concrete event, B none
  selA.value='E1'; selB.value='';
}
populateDieSelectors();

function renderDieSpace(){
  const wrap = byId('die-space'); wrap.innerHTML='';
  Ω.forEach(o=>{ const d=document.createElement('div'); d.style.border="1px solid var(--border)"; d.style.borderRadius="6px"; d.style.padding="4px 4px"; d.style.fontSize="11px"; d.style.textAlign="center"; d.textContent=o; wrap.appendChild(d); });
}
renderDieSpace();

function renderDieTree(){
  const svg = byId('die-tree'); svg.innerHTML='';
  const W=520,H=360; svg.setAttribute('width',W); svg.setAttribute('height',H);
  const rootX=40, rootY=H/2, midX=160, leafX=340, vGap=H/5;
  const Akey = byId('die-event-a').value, Bkey = byId('die-event-b').value, showOnly = byId('die-show-only').checked;
  const Aset = (dieEvents[Akey]?.outcomes) || [], Bset = (dieEvents[Bkey]?.outcomes) || [];
  addCircle(svg, rootX, rootY, 4.5, '#111');
  for(let i=1;i<=4;i++){
    const y1 = vGap*i; addLine(svg, rootX, rootY, midX, y1, '#999'); addCircle(svg, midX, y1, 3.5, '#444'); addText(svg, midX-5, y1-8, `${i}`, '9.5px', '#444');
    for(let j=1;j<=4;j++){
      const y2 = y1 + (j-2.5)*16; const outcome = `(${i},${j})`;
      const inA=Aset.includes(outcome), inB=Bset.includes(outcome);
      const visible = !showOnly || inA || inB;
      if(visible){ addLine(svg, midX, y1, leafX, y2, '#bbb'); addCircle(svg, leafX, y2, 6.5, inA&&inB?'#86efac':(inA?'#93c5fd':(inB?'#fda4af':'#e5e7eb')), '#333'); addText(svg, leafX+8, y2+3, outcome, '11px', '#333'); }
    }
  }
  function addCircle(svg,x,y,r,fill,stroke='#0000'){ const c=document.createElementNS('http://www.w3.org/2000/svg','circle'); c.setAttribute('cx',x); c.setAttribute('cy',y); c.setAttribute('r',r); c.setAttribute('fill',fill); c.setAttribute('stroke',stroke); svg.appendChild(c); }
  function addLine(svg,x1,y1,x2,y2,stroke){ const l=document.createElementNS('http://www.w3.org/2000/svg','line'); l.setAttribute('x1',x1); l.setAttribute('y1',y1); l.setAttribute('x2',x2); l.setAttribute('y2',y2); l.setAttribute('stroke',stroke); l.setAttribute('stroke-width','1'); svg.appendChild(l); }
  function addText(svg,x,y,text,size='12px',fill='#111'){ const t=document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x',x); t.setAttribute('y',y); t.setAttribute('font-size',size); t.setAttribute('fill',fill); t.textContent=text; svg.appendChild(t); }
}
function renderDieGrid(){
  const svg = byId('die-grid'); if(!svg) return; svg.innerHTML='';
  const W=460,H=320; svg.setAttribute('width',W); svg.setAttribute('height',H);
  // layout
  const PAD=30, GRID=4;
  const boxX=PAD, boxY=PAD, boxW=W-2*PAD, boxH=H-2*PAD;
  // axes rectangle
  const rect=document.createElementNS('http://www.w3.org/2000/svg','rect');
  rect.setAttribute('x',boxX); rect.setAttribute('y',boxY);
  rect.setAttribute('width',boxW); rect.setAttribute('height',boxH);
  rect.setAttribute('fill','#ffffff'); rect.setAttribute('stroke','#cbd5e1'); rect.setAttribute('stroke-width','1.2');
  svg.appendChild(rect);
  // grid lines
  for(let i=1;i<GRID;i++){
    const x=boxX + i*boxW/GRID;
    const y=boxY + i*boxH/GRID;
    const v=document.createElementNS('http://www.w3.org/2000/svg','line');
    v.setAttribute('x1',x); v.setAttribute('y1',boxY);
    v.setAttribute('x2',x); v.setAttribute('y2',boxY+boxH);
    v.setAttribute('stroke','#e5e7eb'); v.setAttribute('stroke-width','1');
    svg.appendChild(v);
    const h=document.createElementNS('http://www.w3.org/2000/svg','line');
    h.setAttribute('x1',boxX); h.setAttribute('y1',y);
    h.setAttribute('x2',boxX+boxW); h.setAttribute('y2',y);
    h.setAttribute('stroke','#e5e7eb'); h.setAttribute('stroke-width','1');
    svg.appendChild(h);
  }
  const Akey = byId('die-event-a').value, Bkey = byId('die-event-b').value, showOnly = byId('die-show-only').checked;
  const A = (dieEvents[Akey]?.outcomes) || [], B = (dieEvents[Bkey]?.outcomes) || [];
  function cellFill(i,j){
    const out = `(${i},${j})`;
    const inA = A.includes(out), inB = B.includes(out);
    if(inA && inB) return '#86efac'; // green overlap
    if(inA) return '#93c5fd';        // blue A
    if(inB) return '#fda4af';        // red B
    return '#f3f4f6';                // light gray
  }
  for(let i=1;i<=GRID;i++){
    for(let j=1;j<=GRID;j++){
      const out = `(${i},${j})`;
      const inA = A.includes(out), inB = B.includes(out);
      if(showOnly && !(inA || inB)) continue;
      const cx = boxX + (i-1)*boxW/GRID;
      const cy = boxY + (GRID-j)*boxH/GRID; // y inverted so j=1 at bottom
      const r=document.createElementNS('http://www.w3.org/2000/svg','rect');
      r.setAttribute('x',cx+6); r.setAttribute('y',cy+6);
      r.setAttribute('width',boxW/GRID-12); r.setAttribute('height',boxH/GRID-12);
      r.setAttribute('rx',4); r.setAttribute('ry',4);
      r.setAttribute('fill', cellFill(i,j));
      r.setAttribute('stroke','#9ca3af'); r.setAttribute('stroke-width','0.8');
      svg.appendChild(r);
      // label
      const t=document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', cx + boxW/GRID/2);
      t.setAttribute('y', cy + boxH/GRID/2 + 4);
      t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','10px'); t.setAttribute('fill','#334155');
      t.textContent = `(${i},${j})`;
      svg.appendChild(t);
    }
  }
  // axes labels
  const tx=document.createElementNS('http://www.w3.org/2000/svg','text'); tx.setAttribute('x', boxX+boxW/2); tx.setAttribute('y', boxY+boxH+24); tx.setAttribute('text-anchor','middle'); tx.setAttribute('font-size','11px'); tx.setAttribute('fill','#475569'); tx.textContent='First die (i) →'; svg.appendChild(tx);
  const ty=document.createElementNS('http://www.w3.org/2000/svg','text'); ty.setAttribute('x', boxX-18); ty.setAttribute('y', boxY+boxH/2); ty.setAttribute('text-anchor','middle'); ty.setAttribute('font-size','11px'); ty.setAttribute('fill','#475569'); ty.setAttribute('transform',`rotate(-90 ${boxX-18} ${boxY+boxH/2})`); ty.textContent='↑ Second die (j)'; svg.appendChild(ty);
}


function renderDieVenn(Akey,Bkey){
  const svg = byId('die-venn'); svg.innerHTML='';
  const W=460,H=320; svg.setAttribute('width',W); svg.setAttribute('height',H);
  addRect(svg,10,10,W-20,H-20,'#f8fafc','#cbd5e1');
  const A = (dieEvents[Akey]?.outcomes) || [], B = (dieEvents[Bkey]?.outcomes) || [];
  const pA=probOf(A), pB=probOf(B), AB=inter(A,B), pAB=probOf(AB);
  const baseR=110, cx=W/2, cy=H/2;
  const rA=Math.max(18, baseR*Math.sqrt(Math.max(pA,0.001))), rB=Math.max(18, baseR*Math.sqrt(Math.max(pB,0.001)));
  if(pA===0 && pB===0){ return; }
  if(pA>0 && pB===0){ addCircleSVG(svg,cx,cy,rA,'rgba(147,197,253,0.45)','#3b82f6'); return; }
  if(pB>0 && pA===0){ addCircleSVG(svg,cx,cy,rB,'rgba(253,164,175,0.45)','#ef4444'); return; }
  // Both nonempty
  const disjoint = AB.length===0, AsubsetB=subset(A,B), BsubsetA=subset(B,A);
  let ax,ay,bx,by;
  if(disjoint){ ax=cx - rA - 20; ay=cy; bx=cx + rB + 20; by=cy; }
  else if(AsubsetB||BsubsetA){ ax=cx; ay=cy; bx=cx; by=cy; }
  else {
    const target = Math.PI*baseR*baseR*pAB;
    let d=distanceForTargetOverlap(rA,rB,target);
    d=Math.max(Math.abs(rA-rB)+1, Math.min(d, rA+rB-1));
    ax=cx-d/2; ay=cy; bx=cx+d/2; by=cy;
  }
  addCircleSVG(svg,bx,by,rB,'rgba(253,164,175,0.45)','#ef4444');
  addCircleSVG(svg,ax,ay,rA,'rgba(147,197,253,0.45)','#3b82f6');
}

function updateDie(){
  const Akey = byId('die-event-a').value, Bkey = byId('die-event-b').value;
  const A = (dieEvents[Akey]?.outcomes) || [];
  const B = (dieEvents[Bkey]?.outcomes) || [];
  const pA=probOf(A), pB=probOf(B), AB=inter(A,B), pAB=probOf(AB), pAorB=probOf(union(A,B)), pAgB=B.length?AB.length/B.length:0;
  setText('die-stats', [
    '|Ω| = 16 (uniform, probability of each outcome = 1/16)',
    `P(A) = |A|/16 = ${A.length}/16 = ${fmtProb(pA)}`,
    `P(B) = |B|/16 = ${B.length}/16 = ${fmtProb(pB)}`,
    `P(A).P(B) = ${fmtProb(pA*pB)}`,
    `P(A∩B) = |A∩B|/16 = ${AB.length}/16 = ${fmtProb(pAB)}`,
    `P(A∪B) = P(A)+P(B)-P(A∩B) = ${fmtProb(pAorB)}`,
    `P(A|B) = |A∩B|/|B| = ${B.length ? `${AB.length}/${B.length}` : '—'} = ${fmtProb(pAgB)}`
  ].join('<br><br>'));
  const disjoint = AB.length===0, AsubsetB=subset(A,B), BsubsetA=subset(B,A), indep=Math.abs(pAB-pA*pB)<1e-12;
  setText('die-rel', `
    <span class="pill">Disjoint?</span> ${disjoint?'<b style="color:#16a34a">Yes</b>':'<b>No</b>'}
    &nbsp; <span class="pill">A ⊆ B?</span> ${AsubsetB?'<b style="color:#16a34a">Yes</b>':'<b>No</b>'}
    &nbsp; <span class="pill">B ⊆ A?</span> ${BsubsetA?'<b style="color:#16a34a">Yes</b>':'<b>No</b>'}
    &nbsp; <span class="pill">Independent?</span> ${indep?'<b style="color:#16a34a">Yes</b>':'<b>No</b>'}
  `);
  renderDieVenn(Akey,Bkey); renderDieTree(); renderDieGrid();
  const list = Object.values(dieEvents).map(ev=>`<div style="display:flex; justify-content:space-between; align-items:center; margin:6px 0;"><div><span class="pill">${ev.name.split(':')[0]}</span> ${ev.name.split(': ')[1]}</div><span style="color:#6b7280; font-family:monospace;">P=${fmtProb(probOf(ev.outcomes))}</span></div>`).join('');
  setText('die-event-desc', list);
}
byId('die-event-a').addEventListener('change', updateDie);
byId('die-event-b').addEventListener('change', updateDie);
byId('die-show-only').addEventListener('change', updateDie);

/* DART */
const dartSVG = byId('dart-svg'); const DW=460, DH=460; dartSVG.setAttribute('width',DW); dartSVG.setAttribute('height',DH);
const mini = byId('dart-mini'); const PAD=10, SIZE=420;

function rect(x,y,w,h,fill,stroke,rx=0){ const r=document.createElementNS('http://www.w3.org/2000/svg','rect'); r.setAttribute('x',x); r.setAttribute('y',y); r.setAttribute('width',w); r.setAttribute('height',h); r.setAttribute('fill',fill); r.setAttribute('stroke',stroke); r.setAttribute('rx',rx); return r; }
function line(x1,y1,x2,y2,stroke){ const l=document.createElementNS('http://www.w3.org/2000/svg','line'); l.setAttribute('x1',x1); l.setAttribute('y1',y1); l.setAttribute('x2',x2); l.setAttribute('y2',y2); l.setAttribute('stroke',stroke); l.setAttribute('stroke-width','1.1'); return l; }
function text(x,y,str,size='12px',fill='#111'){ const t=document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x',x); t.setAttribute('y',y); t.setAttribute('font-size',size); t.setAttribute('fill',fill); t.textContent=str; return t; }
function dot(x,y,color){ const c=document.createElementNS('http://www.w3.org/2000/svg','circle'); c.setAttribute('cx', PAD + x*SIZE); c.setAttribute('cy', PAD + (1-y)*SIZE); c.setAttribute('r', 2); c.setAttribute('fill', color); c.setAttribute('opacity','0.85'); dartSVG.appendChild(c); }

function drawDartFrame(){
  dartSVG.innerHTML='';
  const EXT = PAD + SIZE;
  dartSVG.appendChild(rect(PAD,PAD,SIZE,SIZE,'#fff','#cbd5e1',10));
  dartSVG.appendChild(line(PAD,EXT,EXT,EXT,'#334155')); // x-axis
  dartSVG.appendChild(line(PAD,EXT,PAD,PAD,'#334155')); // y-axis
  for(let i=0;i<=10;i++){
    const x = PAD + (SIZE/10)*i, y = PAD + (SIZE/10)*i;
    if(i>0 && i<10){ dartSVG.appendChild(line(x,PAD,x,EXT,'#e5e7eb')); dartSVG.appendChild(line(PAD,y,EXT,y,'#e5e7eb')); }
    dartSVG.appendChild(line(x,EXT,x,EXT-4,'#334155')); dartSVG.appendChild(line(PAD,y,PAD+4,y,'#334155'));
    const tx = text(x, EXT-6, (i/10).toFixed(1),'10px','#334155'); tx.setAttribute('text-anchor','middle'); dartSVG.appendChild(tx);
    const ty = text(PAD+6, EXT-(SIZE/10)*i+4, (i/10).toFixed(1),'10px','#334155'); ty.setAttribute('text-anchor','start'); dartSVG.appendChild(ty);
  }
  const xLab = text(PAD+SIZE/2, EXT+18, 'x','12px','#111'); xLab.setAttribute('text-anchor','middle'); dartSVG.appendChild(xLab);
  const yLab = text(PAD-6, PAD+SIZE/2, 'y','12px','#111'); yLab.setAttribute('text-anchor','start'); dartSVG.appendChild(yLab);
  // mini
  mini.innerHTML=''; const mW=140,mH=140,mPad=10;
  mini.appendChild(rect(mPad,mPad,mW,mH,'#fff','#94a3b8',8));
  const mx0=mPad,my0=mPad+mH; mini.appendChild(line(mx0,my0,mx0+mW,my0,'#475569')); mini.appendChild(line(mx0,my0,mx0,my0-mH,'#475569'));
  mini.appendChild(line(mx0+mW,my0,mx0+mW,my0-6,'#475569')); mini.appendChild(line(mx0,my0-mH,mx0+6,my0-mH,'#475569'));
  const mtx0=text(mx0,my0+12,'0','9px','#334155'); mtx0.setAttribute('text-anchor','middle'); mini.appendChild(mtx0);
  const mtx1=text(mx0+mW,my0+12,'1','9px','#334155'); mtx1.setAttribute('text-anchor','middle'); mini.appendChild(mtx1);
  const mty1=text(mx0-8,my0-mH+3,'1','9px','#334155'); mty1.setAttribute('text-anchor','end'); mini.appendChild(mty1);
  const mxLab=text(mx0+mW/2,my0+22,'x','10px','#111'); mxLab.setAttribute('text-anchor','middle'); mini.appendChild(mxLab);
  const myLab=text(mx0-12,my0-mH/2,'y','10px','#111'); myLab.setAttribute('text-anchor','end'); mini.appendChild(myLab);
  const title=text(mx0+mW/2,my0-mH/2,'[0,1]²','11px','#334155'); title.setAttribute('text-anchor','middle'); mini.appendChild(title);
}
drawDartFrame();

const dartEvents = {
  E1:{ name:"Event 1: x + y ≤ 0.5", contains:p=>p.x+p.y<=0.5, area:0.125 },
  E2:{ name:"Event 2: x − y ≤ 0.5", contains:p=>(p.x-p.y)<=0.5, area:0.875 },
  E3:{ name:"Event 3: y ≤ x", contains:p=>p.y<=p.x, area:0.5 },
  E4:{ name:"Event 4: x² + y² ≤ 1", contains:p=>(p.x*p.x+p.y*p.y)<=1.0, area:Math.PI/4 },
  E5:{ name:"Event 5: 0.25 ≤ x ≤ 0.75", contains:p=>(p.x>=0.25&&p.x<=0.75), area:0.5 },
  E6:{ name:"Event 6: 0.2 ≤ y ≤ 0.8", contains:p=>(p.y>=0.2&&p.y<=0.8), area:0.6 },
  E7:{ name:"Event 7: x ≤ 0.5", contains:p=>p.x<=0.5, area:0.5 },
  E8:{ name:"Event 8: y ≤ 0.5", contains:p=>p.y<=0.5, area:0.5 },
  E9:{ name:"Event 9: |x − y| ≤ 0.2", contains:p=>Math.abs(p.x-p.y)<=0.2, area:0.36 },
  E10:{name:"Event 10: x² + y² ≤ 0.5", contains:p=>(p.x*p.x+p.y*p.y)<=0.5, area:Math.PI/8 }
};
function populateDartSelectors(){
  const selA = byId('dart-event-a'), selB = byId('dart-event-b');
  // add “(none)” option to enable single-event exploration
  const noneA = document.createElement('option'); noneA.value=""; noneA.textContent="— (none) —"; selA.appendChild(noneA);
  const noneB = document.createElement('option'); noneB.value=""; noneB.textContent="— (none) —"; selB.appendChild(noneB);
  // existing predefined events
  Object.entries(dartEvents).forEach(([k,v])=>{
    let o1=document.createElement('option'); o1.value=k; o1.textContent=v.name; selA.appendChild(o1);
    let o2=document.createElement('option'); o2.value=k; o2.textContent=v.name; selB.appendChild(o2);
  });
  // sensible defaults: A concrete event, B none
  selA.value='E1'; selB.value='';
}
populateDartSelectors();

function drawDartRegion(key, fill, stroke){
  if(!key || !dartEvents[key]) return; // allow “(none)”
  // Color fills for A (blue) and B (red)
  function poly(points){
    const pl=document.createElementNS('http://www.w3.org/2000/svg','polygon');
    pl.setAttribute('points', points.map(([x,y])=>`${PAD+x*SIZE},${PAD+(1-y)*SIZE}`).join(' '));
    pl.setAttribute('fill', fill); pl.setAttribute('stroke', stroke); pl.setAttribute('stroke-width','1.5');
    dartSVG.appendChild(pl);
  }
  function rectR(x0,x1,y0,y1){ const r=document.createElementNS('http://www.w3.org/2000/svg','rect'); const x=PAD+x0*SIZE, y=PAD+(1-y1)*SIZE, w=(x1-x0)*SIZE, h=(y1-y0)*SIZE; r.setAttribute('x',x); r.setAttribute('y',y); r.setAttribute('width',w); r.setAttribute('height',h); r.setAttribute('fill',fill); r.setAttribute('stroke',stroke); r.setAttribute('stroke-width','1.5'); dartSVG.appendChild(r); }
  if(key==='E1'){ poly([[0,0.5],[0.5,0],[0,0]]); }
  else if(key==='E2'){ poly([[0,1],[1,1],[1,0.5],[0.5,0],[0,0]]); }
  else if(key==='E3'){ poly([[0,0],[1,0],[1,1]]); }
  else if(key==='E4'){ const path=document.createElementNS('http://www.w3.org/2000/svg','path'); const cx=PAD, cy=PAD+SIZE; path.setAttribute('d',`M ${cx},${cy} L ${cx+SIZE},${cy} A ${SIZE} ${SIZE} 0 0 0 ${cx},${cy-SIZE} Z`); path.setAttribute('fill',fill); path.setAttribute('stroke',stroke); path.setAttribute('stroke-width','1.5'); dartSVG.appendChild(path); }
  else if(key==='E5'){ rectR(0.25,0.75,0,1); }
  else if(key==='E6'){ rectR(0,1,0.2,0.8); }
  else if(key==='E7'){ rectR(0,0.5,0,1); }
  else if(key==='E8'){ rectR(0,1,0,0.5); }
  else if(key==='E9'){ // band around diagonal |x - y| <= 0.2, single polygon (hexagon)
  // Vertices in unit square order: (0,0) -> (0,0.2) -> (0.8,1) -> (1,1) -> (1,0.8) -> (0.2,0)
  poly([[0,0],[0,0.2],[0.8,1],[1,1],[1,0.8],[0.2,0]]);
}
  else if(key==='E10'){ const path=document.createElementNS('http://www.w3.org/2000/svg','path'); const cx=PAD, cy=PAD+SIZE; const r=Math.sqrt(0.5)*SIZE; path.setAttribute('d',`M ${cx},${cy} L ${cx+r},${cy} A ${r} ${r} 0 0 0 ${cx},${cy-r} Z`); path.setAttribute('fill',fill); path.setAttribute('stroke',stroke); path.setAttribute('stroke-width','1.5'); dartSVG.appendChild(path); }
}

let darts=[];
function throwDarts(n=500){ for(let i=0;i<n;i++) darts.push({x:Math.random(),y:Math.random()}); renderDart(); }
function resetDarts(){ darts=[]; renderDart(); }

function analyticIntersectionArea(keyA,keyB){
  const A=keyA,B=keyB; if(A>B) return analyticIntersectionArea(B,A);
  if(A==='E1'&&B==='E3') return 0.0625;
  if(A==='E2'&&B==='E3') return 0.375;
  if(A==='E5'&&B==='E6') return 0.3;
  if(A==='E3'&&B==='E5') return (0.75*0.75 - 0.25*0.25)/2;
  if(A==='E1'&&B==='E5') return 0.03125;
  if(A==='E1'&&B==='E6') return 0.045;
  return null;
}
function numericIntersectionArea(keyA,keyB){
  const NA=280; let cnt=0;
  for(let i=0;i<NA;i++){ const x=(i+0.5)/NA;
    for(let j=0;j<NA;j++){ const y=(j+0.5)/NA;
      if(dartEvents[keyA].contains({x,y}) && dartEvents[keyB].contains({x,y})) cnt++;
  } }
  return cnt/(NA*NA);
}
function theoreticalIntersection(keyA,keyB){
  if(!keyA || !keyB) return 0;
  const ana=analyticIntersectionArea(keyA,keyB); return (ana!==null)?ana:numericIntersectionArea(keyA,keyB);
}

// approximate subset check for continuous regions
function subsetNumeric(keyA,keyB){
  if(!keyA && keyB) return true;        // ∅ ⊆ B
  if(keyA && !keyB) return false;       // nonempty ⊄ ∅
  if(!keyA && !keyB) return true;       // ∅ ⊆ ∅
  const NA=160;
  for(let i=0;i<NA;i++){
    const x=(i+0.5)/NA;
    for(let j=0;j<NA;j++){
      const y=(j+0.5)/NA;
      if(dartEvents[keyA].contains({x,y}) && !dartEvents[keyB].contains({x,y})) return false;
    }
  }
  return true;
}

function renderDart(){
  drawDartFrame();
  const Akey=byId('dart-event-a').value, Bkey=byId('dart-event-b').value;
  const Aev=dartEvents[Akey], Bev=dartEvents[Bkey];
  if(Akey) drawDartRegion(Akey,'rgba(147,197,253,0.25)','#3b82f6');
  if(Bkey) drawDartRegion(Bkey,'rgba(253,164,175,0.25)','#ef4444');
  darts.slice(-1200).forEach(p=>{
    const inA=Aev?Aev.contains(p):false, inB=Bev?Bev.contains(p):false;
    dot(p.x, p.y, inA&&inB?'#10b981':(inA?'#3b82f6':(inB?'#ef4444':'#111')));
  });
  updateDartStats();
  renderDartVenn();
  renderDartDescriptions();
}
function updateDartStats(){
  const Akey=byId('dart-event-a').value, Bkey=byId('dart-event-b').value;
  const Aev=dartEvents[Akey], Bev=dartEvents[Bkey];
  const N=Math.max(1,darts.length);
  const cA=Aev?darts.filter(p=>Aev.contains(p)).length:0;
  const cB=Bev?darts.filter(p=>Bev.contains(p)).length:0;
  const cAB=(Aev&&Bev)?darts.filter(p=>Aev.contains(p)&&Bev.contains(p)).length:0;
  const pA=cA/N,pB=cB/N,pAB=cAB/N,pAorB=pA+pB-pAB,pAgB=cB>0?cAB/cB:0;
  setText('dart-stats', [
  `N = ${darts.length}`,
  `P̂(A) = ${cA}/${N} = ${fmtProb(pA)}`,
  `P̂(B) = ${cB}/${N} = ${fmtProb(pB)}`,
  `P̂(A∩B) = ${cAB}/${N} = ${fmtProb(pAB)}`,
  `P̂(A∪B) = ${fmtProb(pAorB)}`,
  `P̂(A|B) = ${cB > 0 ? `${cAB}/${cB}` : '—'} = ${fmtProb(pAgB)}`
].join('<br><br>'));
  const pA_th=Aev?Aev.area:0, pB_th=Bev?Bev.area:0, pAB_th=(Aev&&Bev)?theoreticalIntersection(Akey,Bkey):0;
  const pAorB_th = pA_th + pB_th - pAB_th;
  const pAgB_th = pB_th>0 ? (pAB_th/pB_th) : 0;
  const disjoint = pAB_th<1e-6, indep=Math.abs(pAB_th-pA_th*pB_th)<1e-3, Asub=subsetNumeric(Akey,Bkey), Bsub=subsetNumeric(Bkey,Akey);
  setText('dart-theory', [
  `P(A) = ${fmtProb(pA_th)}`,
  `P(B) = ${fmtProb(pB_th)}`,
  `P(A∩B) = ${fmtProb(pAB_th)}`,
  `P(A)·P(B) = ${fmtProb(pA_th * pB_th)}`,
  `P(A∪B) = P(A)+P(B)-P(A∩B) = ${fmtProb(pAorB_th)}`,
  `P(A|B) = P(A∩B)/P(B) = ${pB_th>0 ? fmtProb(pAgB_th) : '—'}`
].join('<br><br>'));
  byId('dart-venn').dataset.pA=pA_th; byId('dart-venn').dataset.pB=pB_th; byId('dart-venn').dataset.pAB=pAB_th;
  setText('dart-rel-top', `
    <span class="pill">Disjoint?</span> ${disjoint?'<b style="color:#16a34a">Yes</b>':'<b>No</b>'}
    &nbsp; <span class="pill">A ⊆ B?</span> ${Asub?'<b style="color:#16a34a">Yes</b>':'<b>No</b>'}
    &nbsp; <span class="pill">B ⊆ A?</span> ${Bsub?'<b style="color:#16a34a">Yes</b>':'<b>No</b>'}
    &nbsp; <span class="pill">Independent?</span> ${indep?'<b style="color:#16a34a">Yes</b>':'<b>No</b>'}
  `);
}
function renderDartDescriptions(){
  const list = Object.values(dartEvents).map(ev=>`<div style="display:flex; justify-content:space-between; align-items:center; margin:6px 0;"><div><span class="pill">${ev.name.split(':')[0]}</span> ${ev.name.split(': ')[1]}</div><span style="color:#6b7280; font-family:monospace;">P = Area = ${fmtProb(ev.area)}</span></div>`).join('');
  setText('dart-event-desc', list);
}
function renderDartVenn(){
  const svg = byId('dart-venn'); svg.innerHTML=''; const W=460,H=320; svg.setAttribute('width',W); svg.setAttribute('height',H);
  const pA=parseFloat(svg.dataset.pA||'0'), pB=parseFloat(svg.dataset.pB||'0'), pAB=parseFloat(svg.dataset.pAB||'0');
  addRect(svg,10,10,W-20,H-20,'#f8fafc','#cbd5e1');
  const baseR=110, cx=W/2, cy=H/2;
  const rA=Math.max(18, baseR*Math.sqrt(Math.max(pA,0.001))), rB=Math.max(18, baseR*Math.sqrt(Math.max(pB,0.001)));
  if(pA<1e-9 && pB<1e-9){ return; }
  if(pA>=1e-9 && pB<1e-9){ addCircleSVG(svg,cx,cy,rA,'rgba(147,197,253,0.45)','#3b82f6'); return; }
  if(pB>=1e-9 && pA<1e-9){ addCircleSVG(svg,cx,cy,rB,'rgba(253,164,175,0.45)','#ef4444'); return; }
  const disjoint=pAB<1e-6, Asub=Math.abs(pAB-pA)<1e-6&&pA<=pB, Bsub=Math.abs(pAB-pB)<1e-6&&pB<=pA;
  let ax,ay,bx,by;
  if(disjoint){ ax=cx-rA-20; ay=cy; bx=cx+rB+20; by=cy; }
  else if(Asub||Bsub){ ax=cx; ay=cy; bx=cx; by=cy; }
  else{ const target=Math.PI*baseR*baseR*pAB; let d=distanceForTargetOverlap(rA,rB,target); d=Math.max(Math.abs(rA-rB)+1, Math.min(d, rA+rB-1)); ax=cx-d/2; ay=cy; bx=cx+d/2; by=cy; }
  addCircleSVG(svg,bx,by,rB,'rgba(253,164,175,0.45)','#ef4444'); addCircleSVG(svg,ax,ay,rA,'rgba(147,197,253,0.45)','#3b82f6');
  const pApB=pA*pB, indep=Math.abs(pApB-pAB)<1e-6;
}
byId('dart-throw-500').addEventListener('click',()=>throwDarts(500));
byId('dart-throw-2000').addEventListener('click',()=>throwDarts(2000));
byId('dart-reset').addEventListener('click',resetDarts);
byId('dart-event-a').addEventListener('change',renderDart);
byId('dart-event-b').addEventListener('change',renderDart);

/* BAYES */
const prior = byId('ba-prior'), likeA = byId('ba-likea'), likeN = byId('ba-likenot');
function bayesValues(){ const pA=parseFloat(prior.value), lA=parseFloat(likeA.value), lN=parseFloat(likeN.value); const evidence=lA*pA+lN*(1-pA); const post=evidence>0?(lA*pA)/evidence:0; return {pA,lA,lN,evidence,post}; }
function renderBayesBars(){
  const svg=byId('bayes-bars'); svg.innerHTML='';
  const {pA,lA,lN,evidence,post}=bayesValues();
  const W=520,H=220,pad=40,barW=60,gap=30,base=H-40,maxH=140;
  function rectBar(x,val,label,fill){ const h=val*maxH; const r=rect(x,base-h,barW,h,fill,'#0000',8); svg.appendChild(r); const t1=document.createElementNS('http://www.w3.org/2000/svg','text'); t1.setAttribute('x',x+barW/2); t1.setAttribute('y',base+16); t1.setAttribute('font-size','11px'); t1.setAttribute('fill','#334155'); t1.setAttribute('text-anchor','middle'); if(label.includes('A<sup>c</sup>')){ const parts=label.split('A<sup>c</sup>'); t1.innerHTML=parts[0]+'A<tspan baseline-shift="super" font-size="8px">c</tspan>'+parts[1]; }else{ t1.textContent=label; } svg.appendChild(t1); const t2=text(x+barW/2,base-h-6,val.toFixed(2),'11px','#111'); t2.setAttribute('text-anchor','middle'); svg.appendChild(t2); }
  svg.appendChild(line(pad,base,W-pad,base,'#334155')); svg.appendChild(line(pad,base-maxH,pad,base,'#334155')); let x=pad+10;
  rectBar(x,pA,'P(A)','rgba(99,102,241,0.9)'); x+=barW+gap; rectBar(x,lA,'P(B|A)','rgba(16,185,129,0.9)'); x+=barW+gap;
  rectBar(x,lN,'P(B|A<sup>c</sup>)','rgba(245,158,11,0.9)'); x+=barW+gap; rectBar(x,evidence,'P(B)','rgba(96,165,250,0.9)'); x+=barW+gap; rectBar(x,post,'P(A|B)','rgba(59,130,246,0.95)');
}
function updateBayes(){
  const {pA,lA,lN,evidence,post}=bayesValues();
  byId('ba-prior-val').textContent=pA.toFixed(2);
  byId('ba-likea-val').textContent=lA.toFixed(2);
  byId('ba-likenot-val').textContent=lN.toFixed(2);
  byId('ba-evidence-line').textContent=`P(B)= ${lA.toFixed(2)}·${pA.toFixed(2)} + ${lN.toFixed(2)}·${(1-pA).toFixed(2)} = ${evidence.toFixed(3)}`;
  byId('ba-posterior').textContent=`P(A|B) = ${post.toFixed(3)}`;
  renderBayesBars();
}
[prior,likeA,likeN].forEach(el=>el.addEventListener('input',updateBayes));

/* Bayes Examples: toggleable load buttons (no slider updates) */
(function(){
  // helper
  function isOpen(el){ return el && el.innerHTML && el.innerHTML.trim()!==""; }
  function close(el){ if(el) el.innerHTML=""; }
  function openWith(el, html){ if(el) el.innerHTML = html; }

  // Medical testing (binary)
  byId('ba-medical').addEventListener('click', ()=>{
    const box = byId('ba-medical-out');
    if(isOpen(box)){ close(box); return; }
    const pA=0.01, pBgA=0.95, pBgNot=0.05;
    const pB = pBgA*pA + pBgNot*(1-pA);
    const post = (pBgA*pA)/pB;
    openWith(box, [
      'Assume P(A)=0.01, P(B|A)=0.95, P(B|A<sup>c</sup>)=0.05.',
      `Evidence: P(B)= ${pBgA.toFixed(2)}·${pA.toFixed(2)} + ${pBgNot.toFixed(2)}·${(1-pA).toFixed(2)} = ${pB.toFixed(3)}.`,
      `Bayes: P(A|B)= (P(B|A)P(A))/P(B) = ${(pBgA*pA).toFixed(3)}/${pB.toFixed(3)} = ${post.toFixed(3)}.`
    ].join('<br>'));
  });

  // Spam detection (binary)
  byId('ba-spam').addEventListener('click', ()=>{
    const box = byId('ba-spam-out');
    if(isOpen(box)){ close(box); return; }
    const pA=0.20, pBgA=0.90, pBgNot=0.10;
    const pB = pBgA*pA + pBgNot*(1-pA);
    const post = (pBgA*pA)/pB;
    openWith(box, [
      'Assume P(A)=0.20 (spam), P(B|A)=0.90 (keyword hit), P(B|A<sup>c</sup>)=0.10.',
      `Evidence: P(B)= 0.90·0.20 + 0.10·0.80 = ${pB.toFixed(3)}.`,
      `Bayes: P(A|B)= (0.90·0.20)/P(B) = ${post.toFixed(3)}.`
    ].join('<br>'));
  });

  // Click prediction (three segments)
  byId('ba-click').addEventListener('click', ()=>{
    const box = byId('ba-click-out');
    if(isOpen(box)){ close(box); return; }
    const p1=0.50, p2=0.30, p3=0.20;
    const l1=0.05, l2=0.12, l3=0.30;
    const pB = p1*l1 + p2*l2 + p3*l3;
    const postH3 = (p3*l3)/pB;
    openWith(box, [
      '<b>Three-way partition</b>: H₁=new (50%), H₂=occasional (30%), H₃=loyal (20%).',
      'Click probs: P(B|H₁)=0.05, P(B|H₂)=0.12, P(B|H₃)=0.30.',
      `Evidence: P(B)= 0.05·0.50 + 0.12·0.30 + 0.30·0.20 = ${pB.toFixed(3)}.`,
      `Posterior: P(H₃|B)= (0.30·0.20)/P(B) = ${postH3.toFixed(3)}.`
    ].join('<br>'));
  });
})();
/* INITIALIZE */
updateDie();
renderDart();
updateBayes();
</script>
</body>
</html>
